import re
import ast
import inspect
import functools
import numpy as np

from .utils import flatten, Netlist
from collections import defaultdict
from itertools import chain


default_freq = 1000.0
dtype = np.complex
wj = 2j * np.pi


# def node(V, node_label, measure="V", Z_ground=None):
#     if measure == "Z":
#         if Z_ground is None:
#             raise AttributeError(
#                 "To calulate impedance a value must be set for `Z_ground`."
#             )
#         data = _v2z(V, node, Z_ground)
#     elif measure == "I":
#         data = (V[:, node] / Z_ground).flatten()
#     elif measure == "V":
#         data = V[:, node].flatten()


def simulator(circuit=None, freq=1000.0, **kwargs):
    """Generates function for simulating circuit.

    Args:
        circuit (, optional): Function or spc.Netlist to create simulating
        function from. Defaults to None.
        freq (float, optional): Frequency/frequencies to simulate circuit over.
        Defaults to 1000.0.

    Raises:
        SyntaxError: Raised if voltage source not specified for circuit.

    Returns:
        function that takes circuit component values as position and keyword
        arguments and simulates voltage response of the circuit nodes.
    """

    freq = np.array(freq).reshape(-1)

    if circuit is not None:
        # If circuit is supplied as a function or string
        if callable(circuit) or (isinstance(circuit, str)):
            netlist, total_nodes, undef_args, def_args = _parse_circuit_func(circuit)
        else:
            # If circuit is supplied as a netlist/dictionary
            netlist, total_nodes, undef_args, def_args = _parse_circuit_dict(
                circuit, **kwargs
            )
        print(netlist, "here")
        length = len(set(total_nodes))
        A = np.zeros((freq.shape[0], length, length), dtype=dtype)
        comp_vals = {}
        for component, val in netlist.items():
            if val["value"]:
                value = val["value"]
                if component[0] != "V":
                    value = _impedance(component, value, freq)
                comp_vals[component] = value
                print(val)
                _stamp(A, val["nodes"], value, voltage_source=val["source"])
        total_args = undef_args + def_args

        @functools.wraps(circuit)
        def wrapper(*args, **kwargs):

            return _solve_circuit(
                A.copy(),
                freq,
                netlist,
                comp_vals,
                length,
                undef_args.copy(),
                *args,
                **kwargs,
            )

        wrapper.__doc__ = (
            "Automatically generated docstring. This function can now be used "
            + "to simulate the voltages across the nodes between the frequencies "
            + f"of {np.min(freq):.3f}-{np.max(freq):.3f}Hz.\n\nValue(s) for the "
            + f"remaning keyword arguments {undef_args} need to be supplied to "
            + "complete the circuit.\n"
        )

        return wrapper

    else:
        return functools.partial(simulator, freq=freq, **kwargs)


def _parse_circuit_func(circuit):
    """Extract netlist from circuit function"""

    nodes = create_nodelist(circuit)

    try:
        args = inspect.getfullargspec(circuit)
        arg_dict = dict(zip(args.args, args.defaults))
        undef_args = sorted(list(circuit.__code__.co_names))
        def_args = args.args
    except TypeError:  # if circuit supplied as a string
        arg_dict = {}
        # Get unique components defined in `nodes`
        undef_args = np.unique(list(chain(*nodes.values()))).tolist()
        def_args = []

    if "V" not in flatten(nodes.values()):
        raise SyntaxError("V not defined for circuit")
    else:
        total_nodes = nodes.keys()
    netlist = _netlist_converter(nodes, arg_dict)

    return netlist, total_nodes, undef_args, def_args


def _parse_circuit_dict(circuit, **kwargs):
    """Extract netlist from circuit dictionary/netlist"""
    if isinstance(circuit, Netlist):
        circuit = circuit.to_dict()
    netlist = {}
    total_nodes = []
    voltage_source = 0
    for key, val in circuit.items():
        new_nodes = []
        for node in val["nodes"]:
            #if node > 0:
            new_nodes.append(node)
        total_nodes.extend(new_nodes)
        netlist[key] = {"nodes": new_nodes, "value": circuit[key]["value"]}
        netlist[key].setdefault("source", False)
        if key[0] == "V":
            voltage_source += 1
            netlist[key]["source"] = voltage_source
    # netlist = circuit
    print(netlist)
    undef_args = sorted([key for key, val in circuit.items() if not val["value"]])

    if voltage_source == 0:
        raise SyntaxError("V not defined for circuit")

    if kwargs:
        for key, val in kwargs.items():
            if isinstance(val, tuple):
                netlist[key] = {
                    "nodes": [val[0][0], val[0][1]],
                    "value": val[1],
                }
            else:
                netlist[key]["value"] = val
        def_args = list(set(netlist.keys()).union(set(kwargs.keys())))
    else:
        def_args = []
#   try:
#       netlist.pop("V")
#   except ValueError:

    return netlist, total_nodes, undef_args, def_args


def _netlist_converter(node_list, argspec):
    """Converts a node list into a netlist"""
    d = defaultdict(dict)
    for node, keys in node_list.items():
        for key in keys:
            if "V" in key.upper():
                continue
            d[key].setdefault("nodes", []).append(node)
            try:
                d[key]["value"] = argspec[key]
            except KeyError:
                d[key]["value"] = None

    return d


def _solve_circuit(A, freq, netlist, comp_vals, length, undef_args, *args, **kwargs):
    """Solves circuit using modified nodal analysis"""
    passed_args = []
 
    for arg in args:

        component = undef_args.pop(0)
        Z = _impedance(component, arg, freq)
        _stamp(A, netlist[component]["nodes"], Z)
        passed_args.append(component)

    for component, val in kwargs.items():

        if component in passed_args:
            raise Exception(f"{component} defined twice")
        else:
            passed_args.append(component)

        if component not in undef_args:
            old_val = comp_vals[component]
            _stamp(A, netlist[component]["nodes"], old_val, subtract=True)
        else:
            undef_args.remove(component)

        Z = _impedance(component, val, freq)
        _stamp(A, netlist[component]["nodes"], Z)

    try:
        undef_args.remove("V")
    except ValueError:
        pass
    if len(undef_args) > 0:
        raise Exception(f"{undef_args[0]} undefined")

    # A[:, 0, -1] = 1
    # A[:, -1, 0] = 1
    b = np.zeros(length)[None, :]
    b[:, -1] = 1
    return np.linalg.solve(A, b)


def create_nodelist(circuit):
    """Identifies nodes in the circuit defined as a function"""
    if callable(circuit):
        func_string = inspect.getsource(circuit)
    elif isinstance(circuit, str):
        func_string = re.sub(r"\n\s*", "\n", circuit)
    tree = ast.parse(func_string)

    netlist = {}
    subcircuits = {}

    def recurse_tree(node):
        nodes = ast.iter_child_nodes(node)

        for i, node in enumerate(nodes):
            node_type = type(node).__name__
            if node_type == "Assign":
                subcircuits[node.targets[0].id] = node.value
            if node_type == "BinOp":
                if type(node.op).__name__ == "Add":

                    netlist[len(netlist) + 1] = [
                        find_component(node.left, "left", subcircuits),
                        find_component(node.right, "right", subcircuits),
                    ]
            recurse_tree(node)

    recurse_tree(tree)

    keys, vals = zip(*netlist.items())
    netlist = {key - 1: flatten(val) for key, val in zip(keys[::-1], vals)}

    return netlist


def find_component(node, side, subcircuit):
    try:
        node = subcircuit[node.id]
    except AttributeError:
        pass
    except KeyError:
        return node.id  # node is Name type and not a subcomponent

    node_type = type(node).__name__

    if node_type == "BinOp":
        if type(node.op).__name__ == "Add":
            if side == "left":
                return find_component(node.right, side, subcircuit)
            elif side == "right":
                return find_component(node.left, side, subcircuit)

        elif (type(node.op).__name__ == "BitOr") or (type(node.op).__name__ == "Mult"):
            return [
                find_component(node.left, side, subcircuit),
                find_component(node.right, side, subcircuit),
            ]


def CPE(Rs, Cs, freq=None):
    """
    Simulates CPE behaviour through a series of R||C components.

    Args:
        freq (array-like):
            The frequencies over which the circuit is simulated.
    Returns:
        Complex impedances or the absolute impedances and phase for
        the CPE.
    """
    if freq is None:
        freq = default_freq

    r_vals = np.array(Rs, dtype=np.complex)
    c_vals = np.array(Cs)
    cpe = np.zeros_like(freq, dtype=np.complex)

    for r, c in zip(r_vals, c_vals):
        cpe = cpe + _parallel_Z(r, C(c, freq))

    return cpe


def _parallel_Z(Z1, Z2):
    """Combined impedance of parallel impedances"""
    return Z1 * Z2 / (Z1 + Z2)


def _impedance(component, value, freq):
    """Calculates 1/impedance from transfer function of component

    Args:
        component (str): Component name in the simpycirc nomenclature
        value (float): Value of component to be simulated in the standard SI
        unit (i.e. farads for capacitor, ohms for resistor)

    Returns:
        np.ndarray: impedance of component over frequency range
    """
    if component[0].upper() == "R":
        return np.full_like(freq, 1 / value, dtype=dtype)
    elif component[:3].upper() == "CPE":
        return 1 / CPE(value[0], value[1], freq)
    elif component[0].upper() == "C":
        return 1 / (1 / (wj * freq * value))
    elif component[0].upper() == "L":
        return 1 / (wj * freq * value)


def _stamp(A, idxs, val, subtract=False, voltage_source=False):
    """Stamp used to update the MNA array of the circuit.

    Args:
        A (np.ndarray): The MNA representation of the circuit.
        idxs (list): The row/column indices representing the components being
        added to the MNA matrix
        val (float): The value of the component to be simulated in the standard SI
        unit (i.e. farads for capacitor, ohms for resistor)
        subtract (bool, optional): To be used to remove a component from the MNA matrix. Defaults to False.
    """

    # Need to have this function take into account V in a netlist

    if subtract:
        val = val * -1
    arr_idxs = [idx_ -1 for idx_ in idxs if idx_ > 0]
    
    if voltage_source:
        print(idxs, 'this is  herrrrrr')
        A[:, arr_idxs[0], -voltage_source] = A[:, arr_idxs[0], -voltage_source] + val
        A[:, -voltage_source, arr_idxs[0]] = A[:, -voltage_source, arr_idxs[0]] + val
        if len(arr_idxs) > 1:
            print(arr_idxs, voltage_source)
            A[:, arr_idxs[1], -voltage_source] = A[:, arr_idxs[1], -voltage_source] - val
            A[:, -voltage_source, arr_idxs[1]] = A[:, -voltage_source, arr_idxs[1]] - val
            return None  # break out early
            
        
    A[:, arr_idxs[0], arr_idxs[0]] = A[:, arr_idxs[0], arr_idxs[0]] + val
    if len(arr_idxs) > 1:
        A[:, arr_idxs[1], arr_idxs[1]] = A[:, arr_idxs[1], arr_idxs[1]] + val
        A[:, arr_idxs[0], arr_idxs[1]] = A[:, arr_idxs[0], arr_idxs[1]] - val
        A[:, arr_idxs[1], arr_idxs[0]] = A[:, arr_idxs[1], arr_idxs[0]] - val
        
